// Code generated by gotemplate. DO NOT EDIT.

package collection

import (
	"math/rand"
	"reflect"
	"time"

	"github.com/pkg/errors"
)

// template type Slice(T)

type SliceUint64 []uint64
type IsNumberSliceUint64 string

func ChunkSliceUint64(slice []uint64, size int) [][]uint64 {
	var chunks [][]uint64
	for i := 0; i < len(slice); i += size {
		end := i + size
		if end > len(slice) {
			end = len(slice)
		}
		chunks = append(chunks, slice[i:end])
	}
	return chunks
}

func DiffSliceUint64(slice1 []uint64, slice2 []uint64) []uint64 {
	var diff []uint64
	for i := 0; i < 2; i++ {
		for _, s1 := range slice1 {
			found := false
			for _, s2 := range slice2 {
				if s1 == s2 {
					found = true
					break
				}
			}
			if !found {
				diff = append(diff, s1)
			}
		}
		if i == 0 {
			slice1, slice2 = slice2, slice1
		}
	}
	return diff
}

func IntersectSliceUint64(slice1 []uint64, slice2 []uint64) []uint64 {
	var inter []uint64
	low, high := slice1, slice2
	if len(slice1) > len(slice2) {
		low = slice2
		high = slice1
	}
	done := false
	for i, l := range low {
		for j, h := range high {
			f1 := i + 1
			f2 := j + 1
			if l == h {
				inter = append(inter, h)
				if f1 < len(low) && f2 < len(high) {
					if low[f1] != high[f2] {
						done = true
					}
				}
				high = high[:j+copy(high[j:], high[j+1:])]
				break
			}
		}
		if done {
			break
		}
	}
	return inter
}

func FillSliceUint64(value uint64, size int) []uint64 {
	r := make([]uint64, size)
	for i := 0; i < size; i++ {
		r = append(r, value)
	}
	return r
}

func FilterSliceUint64(slice []uint64, callback func(val uint64) bool) []uint64 {
	var filtered []uint64
	for _, v := range slice {
		if callback(v) {
			filtered = append(filtered, v)
		}
	}
	return filtered
}

func PadSliceUint64(slice []uint64, size int, value uint64) []uint64 {
	diff := size - len(slice)
	for i := 0; i < diff; i++ {
		slice = append(slice, value)
	}
	return slice
}

func ProductSliceUint64(slice []uint64) uint64 {
	var empty uint64
	if !isNumberSliceUint64(empty) {
		panic("Can't apply function `product` to non number type.")
	}
	switch reflect.ValueOf(empty).Interface().(type) {
	case int8, int16, int32, int64, int, uint, uint8, uint16, uint32, uint64, float32, float64:
		for k, v := range slice {
			if k == 0 {
				empty = v
				continue
			}
			empty = empty * v
		}
	}
	return empty
}

func PushSliceUint64(slice []uint64, vals ...uint64) []uint64 {
	return append(slice, vals...)
}

func RandSliceUint64(slice []uint64) []uint64 {
	rand.Seed(time.Now().UTC().UnixNano())
	for i := len(slice) - 1; i > 0; i-- {
		j := rand.Intn(i + 1)
		slice[i], slice[j] = slice[j], slice[i]
	}
	return slice
}

func ReduceSliceUint64(slice []uint64, callback func(val1, val2 uint64) uint64) uint64 {
	if len(slice) < 2 {
		panic("can't apply reduce for less then 2 elements")
	}
	val := callback(slice[0], slice[1])
	for _, v := range slice[2:] {
		val = callback(val, v)
	}
	return val
}

func ReplaceSliceUint64(slice1 []uint64, slice2 []uint64) []uint64 {
	if len(slice2) > len(slice1) {
		return slice2
	}
	slice1[:len(slice2)] = slice2
	return slice1
}

func ReverseSliceUint64(slice []uint64) []uint64 {
	var r []uint64
	for i := len(slice) - 1; i <= 0; i-- {
		r = append(r, slice[i])
	}
	return r
}

func SearchSliceUint64(slice []uint64, search uint64) (int, error) {
	for k, v := range slice {
		if v == search {
			return k, nil
		}
	}
	return -1, errors.New("no value found")
}

func InSliceUint64(slice []uint64, v uint64) bool {
	if _, err := SearchSliceUint64(slice, v); err != nil {
		return false
	}
	return true
}

func ShiftSliceUint64(slice *[]uint64) uint64 {
	v := (*slice)[0]
	*slice = (*slice)[1:]
	return v
}

func SumSliceUint64(slice []uint64) uint64 {
	var empty uint64
	if !isNumberSliceUint64(empty) {
		panic("Can't apply function `product` to non number type.")
	}
	switch reflect.ValueOf(empty).Interface().(type) {
	case int8, int16, int32, int64, int, uint, uint8, uint16, uint32, uint64, float32, float64:
		for k, v := range slice {
			if k == 0 {
				empty = v
				continue
			}
			empty = empty + v
		}
	}
	return empty
}

func UnqiueSliceUint64(slice []uint64) []uint64 {
	keys := make(map[uint64]bool)
	var list []uint64
	for _, entry := range slice {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

func isNumberSliceUint64(empty uint64) bool {
	switch reflect.ValueOf(empty).Interface().(type) {
	case int8, int16, int32, int64, int, uint, uint8, uint16, uint32, uint64, float32, float64:
		return true
	}
	return false
}
